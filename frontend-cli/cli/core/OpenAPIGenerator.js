import fs from "node:fs"
import path from "node:path"

export class OpenAPIGenerator {
  constructor(openapiSpec) {
    this.openapiSpec = openapiSpec
    this.schemas = openapiSpec.components?.schemas || {}
  }

  determineFolderName() {
    const tags = new Set()

    if (this.openapiSpec.paths) {
      Object.values(this.openapiSpec.paths).forEach((pathItem) => {
        Object.values(pathItem).forEach((operation) => {
          if (operation && operation.tags && Array.isArray(operation.tags)) {
            operation.tags.forEach((tag) => tags.add(tag))
          }
        })
      })
    }

    if (tags.size > 0) {
      const tagArray = Array.from(tags)
      const nonDefaultTag = tagArray.find((tag) => tag.toLowerCase() !== "default")
      if (nonDefaultTag) {
        return this.toKebabCase(nonDefaultTag)
      }
      return this.toKebabCase(tagArray[0])
    }

    if (this.openapiSpec.info && this.openapiSpec.info.title) {
      return this.toKebabCase(this.openapiSpec.info.title)
    }

    return "api-client"
  }

  generateTypesFile() {
    let content = `/**
 * TypeScript Types and Interfaces
 * Generated from OpenAPI specification
 *
 * API: ${this.openapiSpec.info?.title || "API"}
 * Version: ${this.openapiSpec.info?.version || "1.0.0"}
 *
 * @generated by AvangCLI
 */

`

    Object.entries(this.schemas).forEach(([schemaName, schema]) => {
      content += this.generateInterface(schemaName, schema)
      content += "\n"
    })

    if (Object.keys(this.schemas).length === 0) {
      content += "// No schemas defined in OpenAPI specification\n"
    }

    return content
  }

  generateServiceFile(folderName) {
    const className = `${this.toPascalCase(folderName)}Service`
    const baseUrl = this.getBaseUrl()

    let content = `/**
 * API Service Class
 * Generated from OpenAPI specification
 *
 * API: ${this.openapiSpec.info?.title || "API"}
 * Description: ${this.openapiSpec.info?.description || "No description"}
 * Version: ${this.openapiSpec.info?.version || "1.0.0"}
 *
 * @generated by AvangCLI
 */

import type * as Types from "./types"

export interface ${className}Config {
  baseURL?: string;
  headers?: Record<string, string>;
  credentials?: RequestCredentials;
}

/**
 * ${this.openapiSpec.info?.title || className}
 *
 * Singleton service class for API communication
 */
export class ${className} {
  private static instance: ${className} | null = null;
  private baseURL: string;
  private headers: Record<string, string>;
  private credentials?: RequestCredentials;

  private constructor(config?: ${className}Config) {
    this.baseURL = config?.baseURL || '${baseUrl}';
    this.headers = config?.headers || {};
    this.credentials = config?.credentials;
  }

  /**
   * Get singleton instance
   * @param config - Optional configuration (only used on first call)
   * @returns Singleton instance of ${className}
   */
  public static getInstance(config?: ${className}Config): ${className} {
    if (!${className}.instance) {
      ${className}.instance = new ${className}(config);
    }
    return ${className}.instance;
  }

  /**
   * Reset singleton instance (useful for testing)
   */
  public static resetInstance(): void {
    ${className}.instance = null;
  }

  /**
   * Update service configuration
   * @param config - Partial configuration to update
   */
  public configure(config: Partial<${className}Config>): void {
    if (config.baseURL !== undefined) this.baseURL = config.baseURL;
    if (config.headers) this.headers = { ...this.headers, ...config.headers };
    if (config.credentials !== undefined) this.credentials = config.credentials;
  }

  /**
   * Get current base URL
   */
  public getBaseURL(): string {
    return this.baseURL;
  }

  /**
   * Internal fetch wrapper
   * @private
   */
  private async request<T>(
    path: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = \`\${this.baseURL}\${path}\`;
    const headers = {
      'Content-Type': 'application/json',
      ...this.headers,
      ...options.headers,
    };

    const response = await fetch(url, {
      ...options,
      headers,
      credentials: this.credentials,
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({
        detail: response.statusText
      }));
      throw new Error(
        error.detail || \`HTTP \${response.status}: \${response.statusText}\`
      );
    }

    // Handle 204 No Content
    if (response.status === 204) {
      return undefined as T;
    }

    return response.json();
  }

`

    content += this.generateServiceMethods()
    content += "}\n"

    return content
  }

  /**
   * Generate a TypeScript interface from a schema
   */
  generateInterface(name, schema) {
    const sanitizedName = this.sanitizeTypeName(name)

    if (schema.enum) {
      return this.generateEnum(sanitizedName, schema)
    }

    let interfaceCode = ""

    if (schema.description) {
      interfaceCode += `/**\n * ${schema.description}\n */\n`
    }

    interfaceCode += `export interface ${sanitizedName} {\n`

    if (schema.properties) {
      const required = schema.required || []

      Object.entries(schema.properties).forEach(([propName, propSchema]) => {
        const isRequired = required.includes(propName)
        const optional = isRequired ? "" : "?"

        if (propSchema.description) {
          interfaceCode += `  /** ${propSchema.description} */\n`
        }

        const propType = this.resolveType(propSchema)
        interfaceCode += `  ${propName}${optional}: ${propType};\n`
      })
    }

    interfaceCode += "}\n"
    return interfaceCode
  }

  /**
   * Generate a TypeScript enum
   */
  generateEnum(name, schema) {
    let enumCode = ""

    if (schema.description) {
      enumCode += `/**\n * ${schema.description}\n */\n`
    }

    enumCode += `export enum ${name} {\n`

    schema.enum.forEach((value, index) => {
      const enumKey = value
        .toString()
        .toUpperCase()
        .replace(/[^A-Z0-9_]/g, "_")
      enumCode += `  ${enumKey} = "${value}"`
      if (index < schema.enum.length - 1) {
        enumCode += ","
      }
      enumCode += "\n"
    })

    enumCode += "}\n"
    return enumCode
  }

  resolveType(schema, depth = 0) {
    if (schema.$ref) {
      return this.resolveRef(schema.$ref)
    }

    const { isNullable, actualSchema } = this.extractNullability(schema)

    if (actualSchema.allOf) {
      return this.handleAllOf(actualSchema.allOf, depth, isNullable)
    }

    if (actualSchema.anyOf) {
      return this.handleAnyOf(actualSchema.anyOf, depth, isNullable)
    }

    if (actualSchema.oneOf) {
      return this.handleOneOf(actualSchema.oneOf, depth, isNullable)
    }

    if (actualSchema.enum) {
      return this.handleInlineEnum(actualSchema.enum, isNullable)
    }

    if (actualSchema.type === "array") {
      return this.handleArray(actualSchema, depth, isNullable)
    }

    if (actualSchema.type === "object" && actualSchema.properties) {
      return this.handleNestedObject(actualSchema, depth, isNullable)
    }

    if (actualSchema.type === "object" && actualSchema.additionalProperties) {
      return this.handleAdditionalProperties(actualSchema, depth, isNullable)
    }

    return this.handleBasicType(actualSchema, isNullable)
  }

  resolveRef(ref) {
    const refName = ref.split("/").pop()
    return this.sanitizeTypeName(refName)
  }

  extractNullability(schema) {
    let isNullable = false
    let actualSchema = schema

    if (schema.nullable === true) {
      isNullable = true
    }

    if (Array.isArray(schema.type)) {
      const types = schema.type.filter((t) => t !== "null")
      isNullable = schema.type.includes("null")

      if (types.length === 1) {
        actualSchema = { ...schema, type: types[0] }
      } else if (types.length > 1) {
        actualSchema = { ...schema, type: "any" }
      } else {
        actualSchema = { ...schema, type: "null" }
      }
    }

    return { isNullable, actualSchema }
  }

  handleAllOf(allOf, depth, isNullable) {
    const types = allOf.map((s) => this.resolveType(s, depth))
    const baseType = types.join(" & ")
    return this.wrapNullable(baseType, isNullable)
  }

  handleAnyOf(anyOf, depth, isNullable) {
    const types = anyOf.map((s) => this.resolveType(s, depth))
    const baseType = types.join(" | ")
    return this.wrapNullable(baseType, isNullable)
  }

  handleOneOf(oneOf, depth, isNullable) {
    const types = oneOf.map((s) => this.resolveType(s, depth))
    const baseType = types.join(" | ")
    return this.wrapNullable(baseType, isNullable)
  }

  handleInlineEnum(enumValues, isNullable) {
    const values = enumValues.map((v) => (typeof v === "string" ? `"${v}"` : v))
    const baseType = values.join(" | ")
    return this.wrapNullable(baseType, isNullable)
  }

  handleArray(schema, depth, isNullable) {
    const itemType = schema.items ? this.resolveType(schema.items, depth + 1) : "any"
    const baseType = `${itemType}[]`
    return this.wrapNullable(baseType, isNullable)
  }

  handleNestedObject(schema, depth, isNullable) {
    if (depth > 3) {
      return "Record<string, any>"
    }
    const baseType = this.generateInlineInterface(schema, depth)
    return this.wrapNullable(baseType, isNullable)
  }

  handleAdditionalProperties(schema, depth, isNullable) {
    if (typeof schema.additionalProperties === "object") {
      const valueType = this.resolveType(schema.additionalProperties, depth + 1)
      const baseType = `Record<string, ${valueType}>`
      return this.wrapNullable(baseType, isNullable)
    }
    const baseType = "Record<string, any>"
    return this.wrapNullable(baseType, isNullable)
  }

  handleBasicType(schema, isNullable) {
    let baseType

    switch (schema.type) {
      case "string":
        baseType = "string"
        break
      case "number":
      case "integer":
        baseType = "number"
        break
      case "boolean":
        baseType = "boolean"
        break
      case "object":
        baseType = "Record<string, any>"
        break
      case "null":
        return "null"
      default:
        baseType = "any"
    }

    return this.wrapNullable(baseType, isNullable)
  }

  wrapNullable(baseType, isNullable) {
    return isNullable ? `${baseType} | null` : baseType
  }

  generateInlineInterface(schema, depth = 0) {
    const required = schema.required || []
    const props = []

    for (const [propName, propSchema] of Object.entries(schema.properties)) {
      const isRequired = required.includes(propName)
      const optional = isRequired ? "" : "?"
      const propType = this.resolveType(propSchema, depth + 1)
      props.push(`${propName}${optional}: ${propType}`)
    }

    return `{ ${props.join("; ")} }`
  }

  generateServiceMethods() {
    let methods = ""
    const paths = this.openapiSpec.paths || {}

    Object.entries(paths).forEach(([path, pathItem]) => {
      Object.entries(pathItem).forEach(([httpMethod, operation]) => {
        if (["get", "post", "put", "delete", "patch"].includes(httpMethod)) {
          methods += this.generateServiceMethod(path, httpMethod, operation)
          methods += "\n"
        }
      })
    })

    if (methods === "") {
      methods += "  // No operations defined in OpenAPI specification\n"
    }

    return methods
  }

  generateServiceMethod(path, httpMethod, operation) {
    const methodName = operation.operationId
      ? this.toCamelCase(operation.operationId.replace(/_/g, " "))
      : this.toCamelCase(`${httpMethod} ${path.replace(/[{}]/g, "")}`)

    const parameters = operation.parameters || []
    const pathParams = parameters.filter((p) => p.in === "path")
    const queryParams = parameters.filter((p) => p.in === "query")

    let requestBodyType = null
    if (operation.requestBody?.content?.["application/json"]?.schema) {
      const { schema } = operation.requestBody.content["application/json"]
      if (schema.$ref) {
        const rawName = schema.$ref.split("/").pop()
        requestBodyType = this.sanitizeTypeName(rawName)
      }
    }

    let responseType = "unknown"

    if (operation.responses?.["204"]) {
      responseType = "void"
    } else {
      const successResponse = operation.responses?.["200"] || operation.responses?.["201"]
      if (successResponse?.content?.["application/json"]?.schema) {
        const { schema } = successResponse.content["application/json"]
        if (schema.$ref) {
          const rawName = schema.$ref.split("/").pop()
          responseType = `Types.${this.sanitizeTypeName(rawName)}`
        } else if (schema.type || schema.properties || schema.items) {
          responseType = this.resolveType(schema)
        }
      }
    }

    let methodCode = `  /**\n`
    if (operation.summary) {
      methodCode += `   * ${operation.summary}\n`
    }
    if (operation.description && operation.description !== operation.summary) {
      methodCode += `   * \n   * ${operation.description}\n`
    }

    pathParams.forEach((param) => {
      methodCode += `   * @param ${param.name} - ${param.description || "Path parameter"}\n`
    })
    if (requestBodyType) {
      methodCode += `   * @param data - Request body data\n`
    }
    if (queryParams.length > 0) {
      methodCode += `   * @param params - Query parameters\n`
    }

    methodCode += `   * @returns Promise resolving to ${responseType}\n`
    methodCode += `   */\n`

    methodCode += `  public async ${methodName}(`

    const methodParams = []

    pathParams.forEach((param) => {
      const paramType = this.resolveParamType(param)
      methodParams.push(`${param.name}: ${paramType}`)
    })

    if (requestBodyType) {
      methodParams.push(`data: Types.${requestBodyType}`)
    }

    if (queryParams.length > 0) {
      const queryParamsDef = queryParams
        .map((p) => {
          const paramType = this.resolveParamType(p)
          const optional = p.required ? "" : "?"
          return `${p.name}${optional}: ${paramType}`
        })
        .join("; ")
      methodParams.push(`params?: { ${queryParamsDef} }`)
    }

    methodCode += methodParams.join(", ")
    methodCode += `): Promise<${responseType}> {\n`

    let requestPath = path
    pathParams.forEach((param) => {
      requestPath = requestPath.replace(`{${param.name}}`, `\${${param.name}}`)
    })

    if (queryParams.length > 0) {
      methodCode += `    const queryParams = new URLSearchParams();\n`
      queryParams.forEach((param) => {
        methodCode += `    if (params?.${param.name} !== undefined) {\n`
        methodCode += `      queryParams.append('${param.name}', String(params.${param.name}));\n`
        methodCode += `    }\n`
      })
      methodCode += `    const queryString = queryParams.toString();\n`
      methodCode += `    const fullPath = \`${requestPath}\${queryString ? \`?\${queryString}\` : ''}\`;\n\n`
    } else {
      methodCode += `    const fullPath = \`${requestPath}\`;\n\n`
    }

    methodCode += `    return this.request<${responseType}>(fullPath, {\n`
    methodCode += `      method: '${httpMethod.toUpperCase()}',\n`

    if (requestBodyType) {
      methodCode += `      body: JSON.stringify(data),\n`
    }

    methodCode += `    });\n`
    methodCode += `  }\n`

    return methodCode
  }

  resolveParamType(param) {
    if (!param.schema) return "string"

    switch (param.schema.type) {
      case "integer":
      case "number":
        return "number"
      case "boolean":
        return "boolean"
      case "array":
        return "string[]"
      default:
        if (param.schema.format === "uuid") return "string"
        return "string"
    }
  }

  getBaseUrl() {
    if (this.openapiSpec.servers && this.openapiSpec.servers.length > 0) {
      return this.openapiSpec.servers[0].url
    }
    return "http://localhost:8000"
  }

  toKebabCase(str) {
    return str
      .replace(/([a-z])([A-Z])/g, "$1-$2")
      .replace(/[\s_]+/g, "-")
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, "")
  }

  toPascalCase(str) {
    return str
      .split(/[-_\s]+/)
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join("")
  }

  toCamelCase(str) {
    const pascal = this.toPascalCase(str)
    return pascal.charAt(0).toLowerCase() + pascal.slice(1)
  }

  sanitizeTypeName(name) {
    return name.replace(/[-_\s.]/g, "")
  }
}

export async function processOpenAPIFile(openapiPath, outputDir, spinner) {
  const openapiContent = JSON.parse(fs.readFileSync(openapiPath, "utf-8"))
  const generator = new OpenAPIGenerator(openapiContent)

  const folderName = generator.determineFolderName()
  const apiOutputDir = path.join(outputDir, folderName)

  if (!fs.existsSync(apiOutputDir)) {
    fs.mkdirSync(apiOutputDir, { recursive: true })
  }

  spinner.message(`Generating ${folderName}/types.ts and ${folderName}/service.ts...`)

  const typesContent = generator.generateTypesFile()
  fs.writeFileSync(path.join(apiOutputDir, "types.ts"), typesContent)

  const serviceContent = generator.generateServiceFile(folderName)
  fs.writeFileSync(path.join(apiOutputDir, "service.ts"), serviceContent)

  spinner.message(`âœ“ Generated ${folderName}/ with types and services`)
  await new Promise((r) => setTimeout(r, 300))
}
